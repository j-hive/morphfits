"""Configure and setup a program execution of the MorphFITS program.

There are two primary settings objects.
1. RuntimeSettings
    Settings related to runtime configurations, such as paths to data
    directories, which stages to run, which products to remake, etc.
2. ConfigSettings
    Settings related to scientific configurations, such as sigma generation
    algorithm.
"""

# Imports


import logging
import shutil
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Annotated, Union, Optional

from tqdm import tqdm
import yaml
from pydantic import BaseModel, StringConstraints

from . import DATA_ROOT
from .utils import logs, misc


# Constants


pre_logger = logging.getLogger("CONFIG")
logger = logging.getLogger("CONFIG")
"""Logger objects for this module.
"""


## Filesystem


PATH_STANDARDS_PATH = DATA_ROOT / "paths.yaml"
PATH_STANDARDS_DICT = yaml.safe_load(open(PATH_STANDARDS_PATH, mode="r"))
"""Path and dict representing the MorphFITS filesystem structuring standards.
"""


def index_paths(node: dict[str, str | dict], base: str) -> dict[str, str]:
    """Recursively read the MorphFITS filesystem standards YAML file and translate it into a
    dictionary mapping the path names to their corresponding paths, as string
    templates.

    Each value in the dictionary is a full path template, i.e. 'output_ficlo'
    has the value '[root]/[o]/{F}/{I}/{C}/{L}/{O}' and not '{O}'.

    Parameters
    ----------
    node : dict[str, str | dict]
        Dict mapping str path names to their paths (if a file) or subitems (if a
        directory).
    base : str
        Path prior to this node, as a '/'-delimited string.

    Returns
    -------
    dict[str, str]
        Dict mapping path names to their paths, as string templates.
    """
    # Start with an empty dict for this directory
    index = {}

    # Iterate over each subitem of this directory
    for key, value in node.items():
        # Skip meta keys as they are not subitems
        if key == "_name":
            continue

        # Add files to dictionary
        if isinstance(value, str):
            index[key] = base + "/" + value

        # Add subdirectories to dictionary
        else:
            index[key] = value["_name"]
            if len(base) > 0:
                index[key] = base + "/" + index[key]

            # Concatenate this directory's dictionary with the dictionary
            # generated by the subdirectory
            index = index | index_paths(node=value, base=index[key])

    # Return dictionary from path name to path for this directory
    return index


FILESYSTEM = index_paths(node=PATH_STANDARDS_DICT, base="")
"""Paths to directories and files, as structured and named by `PATH_STANDARDS`.
"""


DEFAULT_INPUT_DIRECTORY_NAME = "inputs"
DEFAULT_OUTPUT_DIRECTORY_NAME = "outputs"
DEFAULT_PRODUCT_DIRECTORY_NAME = "products"
DEFAULT_RUN_DIRECTORY_NAME = "runs"
"""Default names for each top-level root directory.
"""


## Required Files


REQUIRED_INPUT_DIRECTORIES = ["input_psfs", "input_fil"]
REQUIRED_OUTPUT_DIRECTORIES = ["output_ficlo", "product_ficlo"]
"""Path names of required directories for MorphFITS to run on a FICLO.
"""


REQUIRED_PRODUCT_FILES = ["stamp", "sigma", "psf", "mask"]
REQUIRED_GALFIT_OUTPUT_FILES = ["model_galfit"]
REQUIRED_IMCASCADE_OUTPUT_FILES = ["model_imcascade"]
REQUIRED_PYSERSIC_OUTPUT_FILES = ["model_pysersic"]
"""Path names of required files for a FICLO to be considered successful.
"""


# Classes


## Models


class FICL(BaseModel):
    """Configuration model for a single FICL.

    FICL is an abbreviation for the field, image version, catalog version, and
    filter of a JWST science observation. Each FICL corresponds to a single
    observation.

    Attributes
    ----------
    field : str
        Field of observation, e.g. "abell2744clu".
    image_version : str
        Version string of JWST image processing, e.g. "grizli-v7.2".
    catalog_version : str
        Version string of JWST cataloging, e.g. "dja-v7.2".
    filter : str
        Observational filter band, e.g. "f140w".
    objects : list[int]
        Integer IDs of galaxies or cluster targets in catalog.
    pixscale : tuple[float, float]
        Pixel scale along x and y axes, in arcseconds per pixel.

    Notes
    -----
    All strings are converted to lowercase upon validation.
    """

    field: Annotated[str, StringConstraints(to_lower=True)]
    image_version: Annotated[str, StringConstraints(to_lower=True)]
    catalog_version: Annotated[str, StringConstraints(to_lower=True)]
    filter: Annotated[str, StringConstraints(to_lower=True)]
    objects: list[int]
    pixscale: tuple[float, float]

    def __str__(self) -> str:
        return "_".join(
            [self.field, self.image_version, self.catalog_version, self.filter]
        )


## Settings


class StageSettings(BaseModel):
    unzip: bool = True
    product: bool = True
    morphology: bool = True
    catalog: bool = True
    histogram: bool = True
    plot: bool = True
    cleanup: bool = True


class ProductSettings(BaseModel):
    stamps: bool = False
    sigmas: bool = False
    psfs: bool = False
    masks: bool = False
    others: bool = False


class GALFITSettings(BaseModel):
    binary: Path


class ImcascadeSettings(BaseModel):
    pass


class PysersicSettings(BaseModel):
    pass


class PathSettings(BaseModel):
    root: Path
    input: Path
    output: Path
    product: Path
    run: Path


class RuntimeSettings(BaseModel):
    roots: PathSettings
    date_time: datetime
    run_number: int
    process_count: int
    process_id: int
    ficls: list[FICL]
    progress_bar: bool
    log_level: int
    stages: Optional[StageSettings] = None
    remake: Optional[ProductSettings] = None
    morphology: Optional[Union[GALFITSettings, ImcascadeSettings, PysersicSettings]] = (
        None
    )

    def setup_directories(self, initialized: bool = True):
        pre_logger.info("Making missing directories.")

        # Create run directory
        get_path(name="run", runtime_settings=self, field=self.ficls[0].field).mkdir(
            parents=True, exist_ok=True
        )

        # If running morphology, only create output and product directories
        if initialized:
            # Iterate over each FICL
            for ficl in self.ficls:
                # Iterate over each object in FICL
                for object in tqdm(ficl.objects, unit="dir", leave=False):
                    # Make leaf FICLO directories
                    for required_directory_name in REQUIRED_OUTPUT_DIRECTORIES:
                        get_path(
                            name=required_directory_name,
                            path_settings=self.roots,
                            ficl=ficl,
                            object=object,
                        ).mkdir(parents=True, exist_ok=True)

        # If running initialize command, only create input directories
        else:
            # Iterate over each FICL
            for ficl in self.ficls:
                # Make PSF and FIL directories, and any parents
                for required_directory_name in REQUIRED_INPUT_DIRECTORIES:
                    get_path(
                        name=required_directory_name,
                        path_settings=self.roots,
                        ficl=ficl,
                    ).mkdir(parents=True, exist_ok=True)

    def cleanup_directories(self):
        logger.info("Removing skipped directories.")

        # Iterate over each FICL
        for ficl in self.ficls:
            # Iterate over each object in FICL
            for object in tqdm(ficl.objects, unit="dir", leave=False):
                # Iterate over each expected product file
                for required_file_name in REQUIRED_PRODUCT_FILES:
                    # Remove product directory for FICLO if any product missing
                    product_path = get_path(
                        name=required_file_name,
                        path_settings=self.roots,
                        ficl=ficl,
                        object=object,
                    )
                    if not product_path.exists():
                        product_ficlo_path = get_path(
                            name="product_ficlo",
                            path_settings=self.roots,
                            ficl=ficl,
                            object=object,
                        )
                        shutil.rmtree(product_ficlo_path)

                # Iterate over each expected output file
                if isinstance(self.morphology, GALFITSettings):
                    required_output_files = REQUIRED_GALFIT_OUTPUT_FILES
                elif isinstance(self.morphology, ImcascadeSettings):
                    required_output_files = REQUIRED_IMCASCADE_OUTPUT_FILES
                else:
                    required_output_files = REQUIRED_PYSERSIC_OUTPUT_FILES
                for required_file_name in required_output_files:
                    # Remove output directory for FICLO if any product missing
                    product_path = get_path(
                        name=required_file_name,
                        path_settings=self.roots,
                        ficl=ficl,
                        object=object,
                    )
                    if not product_path.exists():
                        product_ficlo_path = get_path(
                            name="output_ficlo",
                            path_settings=self.roots,
                            ficl=ficl,
                            object=object,
                        )
                        shutil.rmtree(product_ficlo_path)

    def write(self):
        logger.info("Recording runtime settings.")

        # Initialize empty dict for writing
        settings = {}

        # Add paths as strings
        settings["roots"] = {}
        for root_name in self.roots.__dict__:
            settings["roots"][root_name] = str(self.roots.__dict__[root_name])

        # Add stages as a list of stages ran
        if self.stages is not None:
            settings["stages"] = []
            for stage in self.stages.__dict__:
                if self.stages.__dict__[stage]:
                    settings["stages"].append(stage)

        # Add remake flags as a list of products remade
        if self.remake is not None:
            settings["remake"] = []
            for product in self.remake.__dict__:
                if self.remake.__dict__[product]:
                    settings["remake"].append(product)

        # Add morphology wrapper as a str
        if self.morphology is not None:
            if isinstance(self.morphology, GALFITSettings):
                settings["morphology"] = "GALFIT"
            elif isinstance(self.morphology, ImcascadeSettings):
                settings["morphology"] = "imcascade"
            else:
                settings["morphology"] = "pysersic"

        # Add FICLs as a list of dicts
        settings["ficls"] = []
        for ficl in self.ficls:
            settings["ficls"].append(ficl.__dict__)

        # Add run details
        settings["date_time"] = misc.get_str_from_datetime(date_time=self.date_time)
        settings["run_number"] = misc.get_str_from_run_number(
            run_number=self.run_number
        )
        settings["process_count"] = self.process_count
        settings["process_id"] = self.process_id
        settings["progress_bar"] = self.progress_bar
        settings["log_level"] = self.log_level

        # Write settings to file
        settings_path = get_path(
            name="run_settings", runtime_settings=self, field=self.ficls[0].field
        )
        yaml.safe_dump(settings, open(settings_path, mode="w"))


class ConfigSettings(BaseModel):
    pass


# Functions


## Secondary


def get_path_settings(
    file_settings: dict, cli_settings: dict, initialized: bool
) -> PathSettings:
    path_settings_dict = {}

    try:
        path_settings_dict["root"] = misc.get_path_obj(
            misc.get_preferred_setting(
                name="morphfits_root",
                file_settings=file_settings,
                cli_settings=cli_settings,
            )
        )
    except KeyError:
        pass

    try:
        path_settings_dict["input"] = misc.get_path_obj(
            misc.get_preferred_setting(
                name="input_root",
                file_settings=file_settings,
                cli_settings=cli_settings,
            )
        )
    except KeyError:
        if "root" in path_settings_dict:
            input_root_default = (
                path_settings_dict["root"] / DEFAULT_INPUT_DIRECTORY_NAME
            )
            if initialized:
                if input_root_default.exists():
                    path_settings_dict["input"] = input_root_default
                else:
                    raise KeyError(f"Terminating - input root not found.")
            else:
                path_settings_dict["input"] = input_root_default
        else:
            raise KeyError(f"Terminating - input root not set.")


## Main


def get_path(
    name: str,
    runtime_settings: RuntimeSettings | None = None,
    path_settings: PathSettings | None = None,
    ficl: FICL | None = None,
    morphfits_root: Path | None = None,
    input_root: Path | None = None,
    output_root: Path | None = None,
    product_root: Path | None = None,
    run_root: Path | None = None,
    field: str | None = None,
    image_version: str | None = None,
    catalog_version: str | None = None,
    filter: str | None = None,
    object: int | None = None,
    date_time: datetime | None = None,
    run_number: int | None = None,
) -> Path:
    """Get the path to a MorphFITS file or directory.

    Parameters
    ----------
    name : str
        Name of path to get.
    runtime_settings : RuntimeSettings | None, optional
        Settings for the runtime of MorphFITS, by default None.
    path_settings : PathSettings | None, optional
        Paths to the root directories of MorphFITS, by default None.
    ficl : FICL | None, optional
        FICL object for current iteration in run, by default None.
    morphfits_root : Path | None, optional
        Path to root of MorphFITS filesystem, by default None.
    input_root : Path | None, optional
        Path to root input directory, by default None.
    output_root : Path | None, optional
        Path to root output directory, by default None.
    product_root : Path | None, optional
        Path to root products directory, by default None.
    run_root : Path | None, optional
        Path to root runs directory, by default None.
    field : str | None, optional
        Field of observation, by default None.
    image_version : str | None, optional
        Image version of science frame, by default None.
    catalog_version : str | None, optional
        Catalog version of science frame, by default None.
    filter : str | None, optional
        Filter used in observation, by default None.
    object : int | None, optional
        Target galaxy or cluster ID in catalog, by default None.
    date_time : datetime | None, optional
        Datetime at start of program run, by default None.
    run_number : int | None, optional
        Number of run in collection with same datetime, by default None.

    Returns
    -------
    Path
        Path to file or directory.

    Raises
    ------
    FileNotFoundError
        Passed path name unrecognized.

    See Also
    --------
    data/paths.yaml
        Data standards dictionary detailing MorphFITS paths.
    """
    # Raise error if path name unknown
    if name not in FILESYSTEM:
        raise FileNotFoundError(f"Unknown MorphFITS path name {name}.")

    # Resolve parameters
    # Prefer directly passed parameters to those from settings objects
    if ficl is not None:
        if field is None:
            field = ficl.field
        if image_version is None:
            image_version = ficl.image_version
        if catalog_version is None:
            catalog_version = ficl.catalog_version
        if filter is None:
            filter = ficl.filter
    if runtime_settings is not None:
        if morphfits_root is None:
            morphfits_root = runtime_settings.roots.root
        if input_root is None:
            input_root = runtime_settings.roots.input
        if output_root is None:
            output_root = runtime_settings.roots.output
        if product_root is None:
            product_root = runtime_settings.roots.product
        if run_root is None:
            run_root = runtime_settings.roots.run
        if date_time is None:
            date_time = runtime_settings.date_time
        if run_number is None:
            run_number = runtime_settings.run_number
    if path_settings is not None:
        if morphfits_root is None:
            morphfits_root = path_settings.root
        if input_root is None:
            input_root = path_settings.input
        if output_root is None:
            output_root = path_settings.output
        if product_root is None:
            product_root = path_settings.product
        if run_root is None:
            run_root = path_settings.run

    # Input PSFs - STSci names with uppercase filter names
    if name == "input_psf":
        # Get main filter from pairs like 'f140w-clear'
        if "-" in filter:
            filter_1, filter_2 = filter.split("-")
            filter = filter_1 if "clear" in filter_2 else filter_2

        # Replace filter template with uppercase main filter name
        path.replace("{L}", filter.upper())

    # Replace template in path str with passed value
    path = FILESYSTEM[name]
    path.replace("[root]", str(morphfits_root))
    path.replace("[i]", input_root.name)
    path.replace("[o]", output_root.name)
    path.replace("[p]", product_root.name)
    path.replace("[r]", run_root.name)
    path.replace("{F}", field)
    path.replace("{I}", image_version)
    path.replace("{C}", catalog_version)
    path.replace("{L}", filter)
    path.replace("{O}", object)
    path.replace("{D}", misc.get_str_from_datetime(date_time=date_time))
    path.replace("{N}", misc.get_str_from_run_number(run_number=run_number))

    # Science, exposure, weights images - can contain either 'drc' or 'drz'
    if "{z}" in path:
        # Get paths to both 'drc' and 'drz'
        path_c = misc.get_path_obj(path_like=path.replace("{z}", "c"))
        path_z = misc.get_path_obj(path_like=path.replace("{z}", "z"))

        # Return option that exists
        if path_c.exists():
            return path_c
        elif path_z.exists():
            return path_z
        else:
            raise FileNotFoundError(
                f"Input file '{name}' found with neither 'drc' nor 'drz'."
            )

    # Return resolved path object
    return misc.get_path_obj(path_like=path)


def get_runtime_settings(
    config_path: Path | None = None,
    morphfits_root: Path | None = None,
    input_root: Path | None = None,
    output_root: Path | None = None,
    product_root: Path | None = None,
    run_root: Path | None = None,
    batch_n_process: int = 1,
    batch_process_id: int = 0,
    fields: list[str] | None = None,
    image_versions: list[str] | None = None,
    catalog_versions: list[str] | None = None,
    filters: list[str] | None = None,
    objects: list[str] | None = None,
    object_first: int | None = None,
    object_last: int | None = None,
    progress_bar: bool = False,
    log_level: int = logging.DEBUG,
    skip_unzip: bool = False,
    skip_product: bool = False,
    skip_morphology: bool = False,
    skip_catalog: bool = False,
    skip_histogram: bool = False,
    skip_plot: bool = False,
    skip_cleanup: bool = False,
    remake_all: bool = False,
    remake_stamps: bool = False,
    remake_sigmas: bool = False,
    remake_psfs: bool = False,
    remake_masks: bool = False,
    remake_others: bool = False,
    morphology: str | None = None,
    galfit_path: Path | None = None,
    initialized: bool = False,
) -> RuntimeSettings:
    # Create a temporary logger
    pre_log = tempfile.NamedTemporaryFile()
    base_logger = logs.create_logger(filename=pre_log.name)
    pre_logger = logging.getLogger("CONFIG")
    pre_logger.info("Loading runtime settings.")

    # Set all configurations from YAML file if passed
    if config_path is None:
        config_dict = {}
    else:
        pre_logger.info(f"Loading runtime settings from {config_path}.")
        config_dict = yaml.safe_load(open(config_path, mode="r"))

    # Set all paths
    config_dict = set_paths(
        config_dict=config_dict,
        cli_settings=locals(),
        download_mode=download,
        pre_logger=pre_logger,
    )

    # Set all FICL objects (list[FICL])
    if download:
        config_dict = set_ficls_download_mode(
            config_dict=config_dict, cli_settings=locals(), pre_logger=pre_logger
        )
    else:
        config_dict = set_ficls(
            config_dict=config_dict,
            cli_settings=locals(),
            pre_logger=pre_logger,
            object_first=object_first,
            object_last=object_last,
            batch_n_process=batch_n_process,
            batch_process_id=batch_process_id,
        )

    # Set start datetime and run number
    config_dict = set_run_settings(config_dict=config_dict)

    # Create configuration object from config dict
    morphfits_config = MorphFITSConfig(**config_dict)

    # Terminate if fitter is GALFIT and binary file is not linked
    if ("galfit" in morphfits_config.wrappers) and (
        (morphfits_config.galfit_path is None)
        or (not morphfits_config.galfit_path.exists())
    ):
        raise FileNotFoundError("GALFIT binary file not found or linked.")

    # Setup directories where missing
    morphfits_config.setup_paths(
        pre_logger=pre_logger, display_progress=True, download_mode=download
    )

    # Remove pre-program loggers
    base_logger.handlers.clear()
    pre_logger.handlers.clear()
    pre_log.close()

    # Create program logger and remove pre-program logger
    logger, main_logger = get_loggers(morphfits_config=morphfits_config)
    main_logger.info("Starting MorphFITS.")

    # Display if batch mode
    if batch_n_process > 1:
        main_logger.info("Running in batch mode.")
        main_logger.info(f"Batch process: {batch_process_id} / {batch_n_process-1}")

    # Return configuration object
    return morphfits_config


def get_config_settings() -> ConfigSettings:
    pass


def get_settings(
    config_path: Path | None = None,
    morphfits_root: Path | None = None,
    input_root: Path | None = None,
    output_root: Path | None = None,
    product_root: Path | None = None,
    run_root: Path | None = None,
    batch_n_process: int = 1,
    batch_process_id: int = 0,
    fields: list[str] | None = None,
    image_versions: list[str] | None = None,
    catalog_versions: list[str] | None = None,
    filters: list[str] | None = None,
    objects: list[int] | None = None,
    object_first: int | None = None,
    object_last: int | None = None,
    progress_bar: bool = False,
    log_level: int = logging.DEBUG,
    skip_unzip: bool = False,
    skip_product: bool = False,
    skip_morphology: bool = False,
    skip_catalog: bool = False,
    skip_histogram: bool = False,
    skip_plot: bool = False,
    skip_cleanup: bool = False,
    remake_all: bool = False,
    remake_stamps: bool = False,
    remake_sigmas: bool = False,
    remake_psfs: bool = False,
    remake_masks: bool = False,
    remake_others: bool = False,
    morphology: str | None = None,
    galfit_path: Path | None = None,
    initialized: bool = True,
) -> tuple[RuntimeSettings, ConfigSettings]:
    runtime_settings = get_runtime_settings(
        config_path=config_path,
        morphfits_root=morphfits_root,
        input_root=input_root,
        output_root=output_root,
        product_root=product_root,
        run_root=run_root,
        batch_n_process=batch_n_process,
        batch_process_id=batch_process_id,
        fields=fields,
        image_versions=image_versions,
        catalog_versions=catalog_versions,
        filters=filters,
        objects=objects,
        object_first=object_first,
        object_last=object_last,
        progress_bar=progress_bar,
        log_level=log_level,
        skip_unzip=skip_unzip,
        skip_product=skip_product,
        skip_morphology=skip_morphology,
        skip_catalog=skip_catalog,
        skip_histogram=skip_histogram,
        skip_plot=skip_plot,
        skip_cleanup=skip_cleanup,
        remake_all=remake_all,
        remake_stamps=remake_stamps,
        remake_sigmas=remake_sigmas,
        remake_psfs=remake_psfs,
        remake_masks=remake_masks,
        remake_others=remake_others,
        morphology=morphology,
        galfit_path=galfit_path,
        initialized=initialized,
    )
    config_settings = get_config_settings()
    return runtime_settings, config_settings
