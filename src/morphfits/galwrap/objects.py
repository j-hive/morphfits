"""Object models used in various modules of GalWrap. These objects are here to
resolve circular dependency issues.
"""

# Imports


import logging
import itertools
from pathlib import Path
from typing import Optional, Generator, Annotated

from pydantic import BaseModel, StringConstraints

from .. import PATH_NAMES


# Logging


logger = logging.getLogger("GALWRAP")


# Classes


LowerStr = Annotated[str, StringConstraints(to_lower=True)]
"""Lowercase string type for pydantic model.
"""


class FICLO(BaseModel):
    """Configuration model for a single program execution of GALFIT.

    Parameters
    ----------
    BaseModel : class
        Base pydantic model class to enforce type validation upon creation.

    Attributes
    ----------
    field : str
        Field of observation, e.g. "abell2744clu".
    image_version : str
        Version string of JWST image processing, e.g. "grizli-v7.2".
    catalog_version : str
        Version string of JWST cataloging, e.g. "dja-v7.2".
    filter : str
        Observational filter band, e.g. "f140w".
    object : int
        Integer ID of galaxy or cluster target in catalog, e.g. `1003`.
    pixscale : str, optional
        Pixel scale, in arcseconds per pixel, by default `0.04`, corresponding
        to "40mas".
    morphology_version : str, optional
        Version string of morphology fitting method, by default "galfit".

    Notes
    -----
    All strings upon instantiation will be converted to lowercase.
    FICLO refers to the Field, Image version, Catalog version, fiLter, and
    Object of a GALFIT execution.
    """

    field: LowerStr
    image_version: LowerStr
    catalog_version: LowerStr
    filter: LowerStr
    object: int
    pixscale: float = 0.04
    morphology_version: LowerStr = "galfit"


class GalWrapConfig(BaseModel):
    """Configuration model for a program execution of GalWrap.

    Parameters
    ----------
    BaseModel : class
        Base pydantic model class to enforce type validation upon creation.

    Attributes
    ----------
    input_root : Path
        Path to root directory of input products, e.g. catalogs, science images,
        and PSFs.
    product_root : Path
        Path to root directory of products generated by this program to execute
        GALFIT, e.g. cutouts/stamps, masks, and feedfiles.
    output_root : Path
        Path to root directory of GALFIT output products, e.g. morphology model
        and plots.
    fields : list[str]
        List of fields over which to execute GALFIT.
    image_versions : list[str]
        List of image versions over which to execute GALFIT.
    catalog_versions : list[str]
        List of catalog versions over which to execute GALFIT.
    filters : list[str]
        List of filter bands over which to execute GALFIT.
    objects : list[int]
        List of target IDs over which to execute GALFIT, for each catalog.
    pixscales : list[float], optional
        List of pixel scales over which to execute GALFIT, by default only `0.04`,
        corresponding to "40mas".
    morphology_versions : list[str], optional
        List of morphology fitting methods to execute, by default only GALFIT.
    """

    input_root: Path
    product_root: Path
    output_root: Path
    fields: list[str]
    image_versions: list[str]
    catalog_versions: list[str]
    filters: list[str]
    objects: list[int]
    pixscales: list[float] = [0.04]
    morphology_versions: list[str] = ["galfit"]

    def get_ficlos(
        self,
        fields: list[str] | None = None,
        image_versions: list[str] | None = None,
        catalog_versions: list[str] | None = None,
        filters: list[str] | None = None,
        objects: list[int] | None = None,
        pixscales: list[float] | None = None,
        morphology_versions: list[str] | None = None,
    ) -> Generator[FICLO, None, None]:
        """Generate all FICLO permutations from passed configurations, or
        program configurations if former not passed.

        Parameters
        ----------
        fields : list[str] | None, optional
            List of fields over which to execute GALFIT, by default None (all).
        image_versions : list[str] | None, optional
            List of image versions over which to execute GALFIT, by default None
            (all).
        catalog_versions : list[str] | None, optional
            List of catalog versions over which to execute GALFIT, by default
            None (all).
        filters : list[str] | None, optional
            List of filters over which to execute GALFIT, by default None (all).
        objects : list[int] | None, optional
            List of target IDs corresponding to images and their catalogs, over
            which to execute GALFIT, by default None (all).
        pixscales : list[float] | None, optional
            List of pixel scales over which to execute GALFIT, by default None
            (all).
        morphology_versions : list[str] | None, optional
            List of morphology fitting methods to execute, by default None
            (all).

        Yields
        ------
        FICLO
            FICLO permutation from passed parameters.
        """
        for (
            field,
            image_version,
            catalog_version,
            filter,
            object,
            pixscale,
            morphology_version,
        ) in itertools.product(
            self.fields if fields is None else fields,
            self.image_versions if image_versions is None else image_versions,
            self.catalog_versions if catalog_versions is None else catalog_versions,
            self.filters if filters is None else filters,
            self.objects if objects is None else objects,
            self.pixscales if pixscales is None else pixscales,
            (
                self.morphology_versions
                if morphology_versions is None
                else morphology_versions
            ),
        ):
            yield FICLO(
                field=field,
                image_version=image_version,
                catalog_version=catalog_version,
                filter=filter,
                object=object,
                pixscale=pixscale,
                morphology_version=morphology_version,
            )


class GalWrapPath(BaseModel):
    """Path model for a single path in the GalWrap filesystem structure.

    Parameters
    ----------
    BaseModel : class
        Base pydantic model class to enforce type validation upon creation.

    Attributes
    ----------
    file : bool
        Flag for whether path is a file.
    name : str
        Name of directory or file path points to.
    path : str
        Full path to directory or file path points to, as a string with
        templates (i.e. keywords wrapped in curly braces, e.g. {L} or {root}).
    alts : list[sr]
        List of recognized alternate names for this path.
    """

    file: bool
    name: str
    path: str
    alts: list[str]

    def _replace_template(
        node_name: str,
        root: str | Path | None = None,
        field: str | None = None,
        field_2: str | None = None,
        image_version: str | None = None,
        catalog_version: str | None = None,
        filter: str | None = None,
        object: int | None = None,
        pixname: str | None = None,
    ) -> str:
        """Get a corresponding value for a string template, i.e. '{template_name}'.

        Parameters
        ----------
        node_name : str
            Name of node
        root : str | Path | None, optional
            Path to root data directory containing input, products, and output
            directories, by default None.
        field : str | None, optional
            Field of observation, by default None.
        field_2 : str | None, optional
            Second field to compare to first, by default None. Only used for
            crossmatch files.
        image_version : str | None, optional
            Image version of science frame, by default None.
        catalog_version : str | None, optional
            Catalog version of science frame, by default None.
        filter : str | None, optional
            Filter used in observation, by default None.
        object : int | None, optional
            Target galaxy or cluster ID in science frame, by default None.
        pixname : str | None, optional
            Pixel scale in human-friendly format, by default None.

        Returns
        -------
        str
            Template replaced with corresponding value.

        Raises
        ------
        ValueError
            Template unrecognized or missing value.
        """
        template_name = node_name.split("{")[1].split("}")[0]
        # If template_name is parent path, resolve that and return
        if template_name in GALWRAP_PATHS:
            return GALWRAP_PATHS[template_name]._resolve_single(
                root=root,
                field=field,
                field_2=field_2,
                image_version=image_version,
                catalog_version=catalog_version,
                filter=filter,
                object=object,
                pixname=pixname,
            )
        # If template_name is variable, return corresponding passed variable
        elif (template_name == "root") and (root is not None):
            return str(root) if isinstance(root, Path) else root
        elif (template_name == "F") and (field is not None):
            return field
        elif (template_name == "F2") and (field_2 is not None):
            return field_2
        elif (template_name == "I") and (image_version is not None):
            return image_version
        elif (template_name == "C") and (catalog_version is not None):
            return catalog_version
        elif (template_name == "L") and (filter is not None):
            return filter
        elif (template_name == "O") and (object is not None):
            return str(object)
        elif (template_name == "P") and (pixname is not None):
            return pixname
        # Otherwise, template_name is unrecognized or not passed a value
        else:
            raise ValueError(
                f"Template '{template_name}' unrecognized " + f"or missing a value."
            )

    def resolve(
        self,
        root: str | Path | None = None,
        field: str | None = None,
        field_2: str | None = None,
        image_version: str | None = None,
        catalog_version: str | None = None,
        filter: str | None = None,
        object: int | None = None,
        pixname: str | None = None,
    ) -> Path | None:
        """Get the full path for this path object for passed configuration
        parameters.

        Parameters
        ----------
        root : str | Path | None, optional
            Path to root data directory containing input, products, and output
            directories, by default None.
        field : str | None, optional
            Field of observation, by default None.
        field_2 : str | None, optional
            Second field to compare to first, by default None. Only used for
            crossmatch files.
        image_version : str | None, optional
            Image version of science frame, by default None.
        catalog_version : str | None, optional
            Catalog version of science frame, by default None.
        filter : str | None, optional
            Filter used in observation, by default None.
        object : int | None, optional
            Target galaxy or cluster ID in science frame, by default None.
        pixname : str | None, optional
            Pixel scale in human-friendly format, by default None.

        Returns
        -------
        Path
            Full path to directory or file corresponding to this path object.
        """
        # Populate list with replaced directory and file names
        str_nodes = []
        # Iterate over each node, i.e. directory level or file if leaf node
        for node_name in self.path.split("/"):
            # If curly brace is in the node name, the whole name is a template
            if "{" in node_name:
                # Leaf nodes are handled differently
                if node_name == "{name}":
                    # Filenames are templates separated by underscores
                    if self.file:
                        filename_segments = []
                        for filename_segment in node_name.split("_"):
                            filename_segments.append(
                                GalWrapPath._replace_template(
                                    node_name=filename_segment,
                                    root=root,
                                    field=field,
                                    field_2=field_2,
                                    image_version=image_version,
                                    catalog_version=catalog_version,
                                    filter=filter,
                                    object=object,
                                    pixname=pixname,
                                )
                                if "{" in filename_segment
                                else filename_segment
                            )
                        str_nodes.append("_".join(filename_segments))
                    # Directory names are always templates or strings
                    else:
                        str_nodes.append(
                            GalWrapPath._replace_template(
                                node_name=self.name,
                                root=root,
                                field=field,
                                field_2=field_2,
                                image_version=image_version,
                                catalog_version=catalog_version,
                                filter=filter,
                                object=object,
                                pixname=pixname,
                            )
                            if "{" in self.name
                            else self.name
                        )
                # If the node has a brace and is not a leaf node
                str_nodes.append(
                    GalWrapPath._replace_template(
                        node_name=node_name,
                        root=root,
                        field=field,
                        field_2=field_2,
                        image_version=image_version,
                        catalog_version=catalog_version,
                        filter=filter,
                        object=object,
                        pixname=pixname,
                    )
                )
            # If the node does not have a template in its name
            else:
                str_nodes.append(node_name)

        # Join paths together and cast to full path
        full_path = Path("/".join(str_nodes)).resolve()

        # Only return if the path points to an existing directory or file
        if full_path.exists():
            return full_path
        else:
            logger.info(f"{full_path} does not exist, skipping.")


# Instants


GALWRAP_PATHS = {
    path_name: GalWrapPath(**path_dict) for path_name, path_dict in PATH_NAMES.items()
}
"""Dict of paths used in GalWrap, where the key, value pair is the path's
`path_name`, then a `GalWrapPath` instance.
"""
